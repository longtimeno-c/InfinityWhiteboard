<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Whiteboard</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #toolbar {
            padding: 10px;
            background: #f0f0f0;
            width: 100%;
            text-align: center;
        }
        #whiteboard {
            border: 1px solid #000;
            cursor: crosshair;
            touch-action: none;
        }
        #status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 3px;
        }
        .connected { background: #90ee90; }
        .disconnected { background: #ff9999; }
        .tool-button {
            padding: 5px 10px;
            margin: 0 5px;
            border: 2px solid #ccc;
            border-radius: 5px;
            background: #fff;
            cursor: pointer;
        }
        .tool-button.active {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        select, input[type="range"] {
            margin: 0 5px;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <button id="penTool" class="tool-button active" onclick="setTool('pen')">Pen</button>
        <select id="colorPicker" onchange="setColor(this.value)">
            <option value="black">Black</option>
            <option value="red">Red</option>
            <option value="blue">Blue</option>
            <option value="green">Green</option>
        </select>
        <button id="eraserTool" class="tool-button" onclick="setTool('eraser')">Eraser</button>
        <button id="panTool" class="tool-button" onclick="setTool('pan')">Pan</button>
        <button class="tool-button" onclick="clearBoard()">Clear</button>
        <button class="tool-button" onclick="undo()">Undo</button>
        <button class="tool-button" onclick="redo()">Redo</button>
        <input type="range" id="size" min="1" max="20" value="2" onchange="setSize(this.value)">
        <button class="tool-button" onclick="zoom(1.2)">Zoom In</button>
        <button class="tool-button" onclick="zoom(0.8)">Zoom Out</button>
    </div>
    <canvas id="whiteboard"></canvas>
    <div id="status" class="disconnected">Disconnected</div>

    <script>
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        let tool = 'pen';
        let color = 'black';
        let size = 2;
        let drawing = false;
        let lastX, lastY;
        let history = [];
        let redoStack = [];
        let scale = 1;
        let offsetX = 0, offsetY = 0;
        const GRID_SIZE = 20;

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Tool UI elements
        const penTool = document.getElementById('penTool');
        const eraserTool = document.getElementById('eraserTool');
        const panTool = document.getElementById('panTool');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - document.getElementById('toolbar').offsetHeight;
            redraw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function setTool(newTool) {
            tool = newTool;
            canvas.style.cursor = tool === 'pan' ? 'grab' : 'crosshair';
            penTool.classList.toggle('active', tool === 'pen');
            eraserTool.classList.toggle('active', tool === 'eraser');
            panTool.classList.toggle('active', tool === 'pan');
        }

        function setColor(newColor) {
            color = newColor;
        }

        function setSize(newSize) {
            size = parseInt(newSize);
        }

        function zoom(factor) {
            scale *= factor;
            redraw();
        }

        function clearBoard() {
            history.push({ type: 'clear' });
            redoStack = [];
            socket.send(JSON.stringify({ type: 'clear' }));
            redraw();
        }

        function drawGrid() {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, offsetX, offsetY);
            ctx.scale(scale, scale);

            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5 / scale;

            const minX = -offsetX / scale;
            const minY = -offsetY / scale;
            const maxX = (canvas.width - offsetX) / scale;
            const maxY = (canvas.height - offsetY) / scale;

            for (let x = Math.floor(minX / GRID_SIZE) * GRID_SIZE; x <= maxX; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, minY);
                ctx.lineTo(x, maxY);
                ctx.stroke();
            }
            for (let y = Math.floor(minY / GRID_SIZE) * GRID_SIZE; y <= maxY; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(minX, y);
                ctx.lineTo(maxX, y);
                ctx.stroke();
            }
            ctx.restore();
        }

        canvas.addEventListener('pointerdown', startDrawing);
        canvas.addEventListener('pointermove', draw);
        canvas.addEventListener('pointerup', stopDrawing);
        canvas.addEventListener('pointerleave', stopDrawing);
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom(e.deltaY > 0 ? 0.9 : 1.1);
        });

        function startDrawing(e) {
            e.preventDefault();
            drawing = true;
            const rect = canvas.getBoundingClientRect();
            const virtualX = (e.clientX - rect.left - offsetX) / scale;
            const virtualY = (e.clientY - rect.top - offsetY) / scale;
            [lastX, lastY] = [virtualX, virtualY];
            if (tool === 'pan') {
                canvas.style.cursor = 'grabbing';
            }
        }

        function draw(e) {
            e.preventDefault();
            if (!drawing) return;

            const rect = canvas.getBoundingClientRect();
            const virtualX = (e.clientX - rect.left - offsetX) / scale;
            const virtualY = (e.clientY - rect.top - offsetY) / scale;
            const pressure = e.pressure || 1;

            if (tool === 'pen' && e.buttons === 1) {
                // Improved pen: Quadratic curve for smoother lines
                ctx.beginPath();
                ctx.moveTo(lastX * scale + offsetX, lastY * scale + offsetY);
                const midX = (lastX + virtualX) / 2;
                const midY = (lastY + virtualY) / 2;
                ctx.quadraticCurveTo(lastX * scale + offsetX, lastY * scale + offsetY, midX * scale + offsetX, midY * scale + offsetY);
                ctx.lineTo(virtualX * scale + offsetX, virtualY * scale + offsetY);
                ctx.strokeStyle = color;
                ctx.lineWidth = size * scale * pressure;
                ctx.stroke();
                socket.send(JSON.stringify({
                    type: 'draw',
                    tool: 'pen',
                    color,
                    size: size * pressure,
                    lastX,
                    lastY,
                    x: virtualX,
                    y: virtualY
                }));
                history.push({ type: 'draw', tool: 'pen', color, size: size * pressure, lastX, lastY, x: virtualX, y: virtualY });
                redoStack = [];
            } else if (tool === 'eraser' && e.buttons === 1) {
                // Eraser only affects drawing layer
                ctx.beginPath();
                ctx.arc(virtualX * scale + offsetX, virtualY * scale + offsetY, size * scale * pressure, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0)'; // Transparent fill to erase
                ctx.fill();
                socket.send(JSON.stringify({
                    type: 'draw',
                    tool: 'eraser',
                    size: size * pressure,
                    x: virtualX,
                    y: virtualY
                }));
                history.push({ type: 'draw', tool: 'eraser', size: size * pressure, x: virtualX, y: virtualY });
                redoStack = [];
            } else if (tool === 'pan') {
                offsetX += e.movementX;
                offsetY += e.movementY;
                socket.send(JSON.stringify({
                    type: 'move',
                    offsetX,
                    offsetY
                }));
                redraw();
            }
            [lastX, lastY] = [virtualX, virtualY];
        }

        function stopDrawing(e) {
            drawing = false;
            if (tool === 'pan') {
                canvas.style.cursor = 'grab';
            }
        }

        function undo() {
            if (history.length === 0) return;
            socket.send(JSON.stringify({ type: 'undo' }));
            const action = history.pop();
            redoStack.push(action);
            redraw();
        }

        function redo() {
            if (redoStack.length === 0) return;
            const action = redoStack.pop();
            history.push(action);
            socket.send(JSON.stringify({ type: 'redo' }));
            redraw();
        }

        function redraw() {
            // Draw grid first (background)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();

            // Draw content on top
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, offsetX, offsetY);
            ctx.scale(scale, scale);

            ctx.globalCompositeOperation = 'source-over'; // Ensure drawing is on top
            history.forEach(action => {
                if (action.type === 'draw' && action.tool === 'pen') {
                    ctx.beginPath();
                    ctx.moveTo(action.lastX, action.lastY);
                    const midX = (action.lastX + action.x) / 2;
                    const midY = (action.lastY + action.y) / 2;
                    ctx.quadraticCurveTo(action.lastX, action.lastY, midX, midY);
                    ctx.lineTo(action.x, action.y);
                    ctx.strokeStyle = action.color;
                    ctx.lineWidth = action.size;
                    ctx.stroke();
                } else if (action.type === 'draw' && action.tool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(action.x, action.y, action.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                } else if (action.type === 'clear') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.fillStyle = 'rgba(0,0,0,1)';
                    ctx.fillRect(-Infinity, -Infinity, Infinity, Infinity);
                    ctx.globalCompositeOperation = 'source-over';
                }
            });

            ctx.restore();
        }

        // WebSocket connection
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsHost = window.location.host;
        const socket = new WebSocket(`${wsProtocol}//${wsHost}`);

        socket.onopen = () => {
            console.log('Connected to WebSocket server');
            status.textContent = 'Connected';
            status.className = 'connected';
        };

        socket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'init') {
                history = data.state.actions;
                redraw();
            } else if (data.type === 'draw') {
                if (data.tool === 'pen') {
                    ctx.beginPath();
                    ctx.moveTo(data.lastX * scale + offsetX, data.lastY * scale + offsetY);
                    const midX = (data.lastX + data.x) / 2;
                    const midY = (data.lastY + data.y) / 2;
                    ctx.quadraticCurveTo(data.lastX * scale + offsetX, data.lastY * scale + offsetY, midX * scale + offsetX, midY * scale + offsetY);
                    ctx.lineTo(data.x * scale + offsetX, data.y * scale + offsetY);
                    ctx.strokeStyle = data.color;
                    ctx.lineWidth = data.size * scale;
                    ctx.stroke();
                    history.push({ type: 'draw', tool: 'pen', color: data.color, size: data.size, lastX: data.lastX, lastY: data.lastY, x: data.x, y: data.y });
                } else if (data.tool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(data.x * scale + offsetX, data.y * scale + offsetY, data.size * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                    history.push({ type: 'draw', tool: 'eraser', size: data.size, x: data.x, y: data.y });
                }
            } else if (data.type === 'move') {
                offsetX = data.offsetX;
                offsetY = data.offsetY;
                redraw();
            } else if (data.type === 'clear') {
                history.push({ type: 'clear' });
                redraw();
            } else if (data.type === 'undo') {
                if (history.length > 0) {
                    redoStack.push(history.pop());
                    redraw();
                }
            } else if (data.type === 'redo') {
                // Redo needs server-side support
            }
        };

        socket.onclose = () => {
            console.log('Disconnected from WebSocket server');
            status.textContent = 'Disconnected';
            status.className = 'disconnected';
        };

        socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            status.textContent = 'Error';
            status.className = 'disconnected';
        };
    </script>
</body>
</html>