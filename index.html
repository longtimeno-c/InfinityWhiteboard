<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Whiteboard</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #toolbar {
            padding: 10px;
            background: #f0f0f0;
            width: 100%;
            text-align: center;
        }
        #whiteboard {
            border: 1px solid #000;
            cursor: crosshair;
            touch-action: none; /* Prevent default touch scrolling */
        }
        #status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 3px;
        }
        .connected { background: #90ee90; }
        .disconnected { background: #ff9999; }
    </style>
</head>
<body>
    <div id="toolbar">
        <button onclick="setTool('pen')">Pen</button>
        <select id="colorPicker" onchange="setColor(this.value)">
            <option value="black">Black</option>
            <option value="red">Red</option>
            <option value="blue">Blue</option>
            <option value="green">Green</option>
        </select>
        <button onclick="setTool('eraser')">Eraser</button>
        <button onclick="clearBoard()">Clear</button>
        <button onclick="undo()">Undo</button>
        <button onclick="redo()">Redo</button>
        <input type="range" id="size" min="1" max="20" value="2" onchange="setSize(this.value)">
        <button onclick="zoom(1.2)">Zoom In</button>
        <button onclick="zoom(0.8)">Zoom Out</button>
    </div>
    <canvas id="whiteboard"></canvas>
    <div id="status" class="disconnected">Disconnected</div>

    <script>
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        let tool = 'pen';
        let color = 'black';
        let size = 2;
        let drawing = false;
        let lastX, lastY;
        let history = [];
        let redoStack = [];
        let scale = 1; // Zoom level
        let offsetX = 0, offsetY = 0; // Translation for panning
        const GRID_SIZE = 20; // Size of grid squares in virtual coordinates

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Set canvas to full window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - document.getElementById('toolbar').offsetHeight;
            redraw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function setTool(newTool) {
            tool = newTool;
            canvas.style.cursor = tool === 'pen' ? 'crosshair' : 'default';
        }

        function setColor(newColor) {
            color = newColor;
        }

        function setSize(newSize) {
            size = parseInt(newSize);
        }

        function zoom(factor) {
            scale *= factor;
            redraw();
        }

        function clearBoard() {
            history.push({ type: 'clear' });
            redoStack = [];
            socket.send(JSON.stringify({ type: 'clear' }));
            redraw();
        }

        // Draw squared background
        function drawGrid() {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, offsetX, offsetY);
            ctx.scale(scale, scale);

            ctx.strokeStyle = '#e0e0e0'; // Light gray grid lines
            ctx.lineWidth = 0.5 / scale; // Thin lines, adjusted for zoom

            // Calculate visible bounds in virtual coordinates
            const minX = -offsetX / scale;
            const minY = -offsetY / scale;
            const maxX = (canvas.width - offsetX) / scale;
            const maxY = (canvas.height - offsetY) / scale;

            // Draw vertical lines
            for (let x = Math.floor(minX / GRID_SIZE) * GRID_SIZE; x <= maxX; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, minY);
                ctx.lineTo(x, maxY);
                ctx.stroke();
            }

            // Draw horizontal lines
            for (let y = Math.floor(minY / GRID_SIZE) * GRID_SIZE; y <= maxY; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(minX, y);
                ctx.lineTo(maxX, y);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Pointer events for stylus/touch/mouse support
        canvas.addEventListener('pointerdown', startDrawing);
        canvas.addEventListener('pointermove', draw);
        canvas.addEventListener('pointerup', stopDrawing);
        canvas.addEventListener('pointerleave', stopDrawing);
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom(e.deltaY > 0 ? 0.9 : 1.1); // Zoom with wheel
        });

        function startDrawing(e) {
            e.preventDefault();
            drawing = true;
            const rect = canvas.getBoundingClientRect();
            const virtualX = (e.clientX - rect.left - offsetX) / scale;
            const virtualY = (e.clientY - rect.top - offsetY) / scale;
            [lastX, lastY] = [virtualX, virtualY];
        }

        function draw(e) {
            e.preventDefault();
            if (!drawing) return;

            const rect = canvas.getBoundingClientRect();
            const virtualX = (e.clientX - rect.left - offsetX) / scale;
            const virtualY = (e.clientY - rect.top - offsetY) / scale;
            const pressure = e.pressure || 1; // Stylus pressure (0-1), default to 1 if unavailable

            if (e.buttons === 4 || (tool === 'pen' && e.buttons === 2)) { // Middle mouse or right-click with pen tool for panning
                offsetX += e.movementX;
                offsetY += e.movementY;
                socket.send(JSON.stringify({
                    type: 'move',
                    offsetX,
                    offsetY
                }));
                redraw();
            } else if (tool === 'pen' && e.buttons === 1) { // Left click or stylus
                ctx.beginPath();
                ctx.moveTo(lastX * scale + offsetX, lastY * scale + offsetY);
                ctx.lineTo(virtualX * scale + offsetX, virtualY * scale + offsetY);
                ctx.strokeStyle = color;
                ctx.lineWidth = size * scale * pressure; // Adjust line width with pressure
                ctx.stroke();
                socket.send(JSON.stringify({
                    type: 'draw',
                    tool: 'pen',
                    color,
                    size: size * pressure, // Send pressure-adjusted size
                    lastX,
                    lastY,
                    x: virtualX,
                    y: virtualY
                }));
                history.push({ type: 'draw', tool: 'pen', color, size: size * pressure, lastX, lastY, x: virtualX, y: virtualY });
                redoStack = [];
            } else if (tool === 'eraser' && e.buttons === 1) {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(virtualX * scale + offsetX, virtualY * scale + offsetY, size * scale * pressure, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
                socket.send(JSON.stringify({
                    type: 'draw',
                    tool: 'eraser',
                    size: size * pressure,
                    x: virtualX,
                    y: virtualY
                }));
                history.push({ type: 'draw', tool: 'eraser', size: size * pressure, x: virtualX, y: virtualY });
                redoStack = [];
            }
            [lastX, lastY] = [virtualX, virtualY];
        }

        function stopDrawing(e) {
            drawing = false;
        }

        function undo() {
            if (history.length === 0) return;
            socket.send(JSON.stringify({ type: 'undo' }));
            const action = history.pop();
            redoStack.push(action);
            redraw();
        }

        function redo() {
            if (redoStack.length === 0) return;
            const action = redoStack.pop();
            history.push(action);
            socket.send(JSON.stringify({ type: 'redo' }));
            redraw();
        }

        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid(); // Draw squared background
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, offsetX, offsetY); // Apply pan
            ctx.scale(scale, scale); // Apply zoom

            history.forEach(action => {
                if (action.type === 'draw' && action.tool === 'pen') {
                    ctx.beginPath();
                    ctx.moveTo(action.lastX, action.lastY);
                    ctx.lineTo(action.x, action.y);
                    ctx.strokeStyle = action.color;
                    ctx.lineWidth = action.size;
                    ctx.stroke();
                } else if (action.type === 'draw' && action.tool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(action.x, action.y, action.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                } else if (action.type === 'clear') {
                    ctx.clearRect(-Infinity, -Infinity, Infinity, Infinity);
                }
            });

            ctx.restore(); // Reset transform
        }

        // WebSocket connection
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsHost = window.location.host;
        const socket = new WebSocket(`${wsProtocol}//${wsHost}`);

        socket.onopen = () => {
            console.log('Connected to WebSocket server');
            status.textContent = 'Connected';
            status.className = 'connected';
        };

        socket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'init') {
                history = data.state.actions;
                redraw();
            } else if (data.type === 'draw') {
                if (data.tool === 'pen') {
                    ctx.beginPath();
                    ctx.moveTo(data.lastX * scale + offsetX, data.lastY * scale + offsetY);
                    ctx.lineTo(data.x * scale + offsetX, data.y * scale + offsetY);
                    ctx.strokeStyle = data.color;
                    ctx.lineWidth = data.size * scale;
                    ctx.stroke();
                    history.push({ type: 'draw', tool: 'pen', color: data.color, size: data.size, lastX: data.lastX, lastY: data.lastY, x: data.x, y: data.y });
                } else if (data.tool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(data.x * scale + offsetX, data.y * scale + offsetY, data.size * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                    history.push({ type: 'draw', tool: 'eraser', size: data.size, x: data.x, y: data.y });
                }
            } else if (data.type === 'move') {
                offsetX = data.offsetX;
                offsetY = data.offsetY;
                redraw();
            } else if (data.type === 'clear') {
                history.push({ type: 'clear' });
                redraw();
            } else if (data.type === 'undo') {
                if (history.length > 0) {
                    redoStack.push(history.pop());
                    redraw();
                }
            } else if (data.type === 'redo') {
                // Redo needs server-side support
            }
        };

        socket.onclose = () => {
            console.log('Disconnected from WebSocket server');
            status.textContent = 'Disconnected';
            status.className = 'disconnected';
        };

        socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            status.textContent = 'Error';
            status.className = 'disconnected';
        };
    </script>
</body>
</html>